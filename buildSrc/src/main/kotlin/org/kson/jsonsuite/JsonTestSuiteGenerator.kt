package org.kson.jsonsuite

import org.kson.GitOps.Companion.ensureCleanGitCheckout
import java.nio.file.Path

/**
 * [JsonTestSuiteGenerator] generates native Kotlin tests based on the tests defined in
 * [JSONTestSuite](https://github.com/nst/JSONTestSuite) and [JSON-Schema-Test-Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite)
 *
 * By generating the tests into pure Kotlin test methods, we not only have the ergonomics of having
 * an actual test method per test from these suites, we also get the benefit of being able to run them across all
 * platforms without wrangling cross-platform file reads
 *
 * See [JsonTestSuiteEditList] for info on the adjustments we make to the JSONTestSuite to suit Kson's needs as a
 * superset of JSON
 *
 * @param jsonTestSuiteSHA The SHA version of the tests to generate from
 * @param projectRoot The absolute path on disk to the root of the project to generate JSONTestSuite tests into
 * @param sourceRoot The source root of the project to place the generated test in, relative to [projectRoot]
 * @param classPackage The package ("org.kson.parser.json") for instance.  NOTES: the caller is responsible for setting
 *                      this correctly
 */
class JsonTestSuiteGenerator(
    val jsonTestSuiteSHA: String,
    val schemaTestSuiteSHA: String,
    private val projectRoot: Path,
    private val sourceRoot: Path,
    private val classPackage: String
) {
    private val buildSrcPath: Path = projectRoot.resolve("buildSrc")

    val jsonTestSuiteRootDir: Path = buildSrcPath.resolve("support/jsonsuite/JSONTestSuite")
    private val testDefinitionFilesDir: Path = jsonTestSuiteRootDir.resolve("test_parsing")
    private val jsonTestSuiteRepoUrl = "https://github.com/nst/JSONTestSuite.git"

    val schemaTestSuiteRootDir: Path = buildSrcPath.resolve("support/jsonsuite/JSON-Schema-Test-Suite")
    private val schemaTestSuiteRepoUrl = "https://github.com/json-schema-org/JSON-Schema-Test-Suite.git"

    private val testClassPackageDir = projectRoot.resolve(sourceRoot).resolve(classPackage.replace('.', '/'))
    val generatedJsonSuiteTestPath: Path =
        testClassPackageDir.resolve("JsonSuiteTest.kt")
    val generatedSchemaSuiteTestPath: Path =
        testClassPackageDir.resolve("JsonSchemaSuiteTest.kt")

    fun generate() {
        // sanity check that we're actually running at the project root
        if (!buildSrcPath.toFile().exists()) {
            throw RuntimeException(
                "Kson project buildSrc/ directory not found.  " +
                        "Is parameter `projectRoot` correct?  Current value: $projectRoot"
            )
        }

        ensureCleanGitCheckout(jsonTestSuiteRepoUrl, jsonTestSuiteSHA, jsonTestSuiteRootDir)
        ensureCleanGitCheckout(schemaTestSuiteRepoUrl, schemaTestSuiteSHA, schemaTestSuiteRootDir)

        //ensure that [testDefinitionFilesDir] contains the desired test source files
        testClassPackageDir.toFile().mkdirs()
        val testDataList = JsonTestDataLoader(testDefinitionFilesDir, projectRoot).loadTestData()
        generatedJsonSuiteTestPath.toFile()
            .writeText(generateJsonSuiteTestClass(this.javaClass.name, classPackage, testDataList))

        generatedSchemaSuiteTestPath.toFile()
            .writeText("""
                package $classPackage
                
                import kotlin.test.Test

                /**
                 * DO NOT MANUALLY EDIT.  This class is GENERATED by `./gradlew generateJsonTestSuite` task 
                 * which calls [${this.javaClass.name}]---see that class for more info.
                 */
                class JsonSchemaSuiteTest {
                    @Test
                    fun placeHolderTest() {
                        println("TODO generate these tests")
                    }
                }
            """.trimIndent())
    }
}

/**
 * The properties used to generate the expected results enum in [generateJsonSuiteTestClass]
 */
private class ResultEnumData {
    companion object {
        const val className = "JsonParseResult"
        const val acceptEntry = "ACCEPT"
        const val acceptEntryForKson = "ACCEPT_FOR_KSON"
        const val rejectEntry = "REJECT"
        const val unspecifiedEntry = "UNSPECIFIED"
    }
}

private class JsonTestData(
    val rawTestName: String,
    val testSource: String,
    val filePathFromProjectRoot: String,
    val testEditType: JsonTestEditType
) {
    val isSkipped = testEditType == JsonTestEditType.SKIP_NEEDS_INVESTIGATION

    /**
     * Create a legal MPP Kotlin test name out of the raw test name by replacing problematic characters
     */
    val testName = rawTestName.replace("-", "DASH").replace(".", "DOT").replace("+", "PLUS").replace("#", "HASH")

    fun parsingRequirement(): String {
        return when (testEditType) {
            JsonTestEditType.ACCEPT_N_FOR_SUPERSET -> {
                if (!rawTestName.startsWith("n_")) {
                    throw RuntimeException("Invalid use of ${JsonTestEditType.ACCEPT_N_FOR_SUPERSET::class.simpleName}: this edit only applies to overriding `n_`-type rejection tests")
                }
                return ResultEnumData.acceptEntryForKson
            }
            JsonTestEditType.SKIP_NEEDS_INVESTIGATION, JsonTestEditType.NONE -> {
                when {
                    rawTestName.startsWith("i_") -> ResultEnumData.unspecifiedEntry
                    rawTestName.startsWith("y_") -> ResultEnumData.acceptEntry
                    rawTestName.startsWith("n_") -> ResultEnumData.rejectEntry
                    else -> throw RuntimeException("Unexpected test prefix---should only have i/y/n tests")
                }
            }
        }
    }
}

private fun generateJsonSuiteTestClass(
    generatorClassName: String,
    testClassPackage: String,
    tests: List<JsonTestData>
): String {
    return """package $testClassPackage

import org.kson.Kson
import org.kson.parser.LoggedMessage
import kotlin.test.Test
import kotlin.test.assertFalse
import kotlin.test.assertTrue

/**
 * DO NOT MANUALLY EDIT.  This class is GENERATED by `./gradlew generateJsonTestSuite` task 
 * which calls [$generatorClassName]---see that class for more info.
 */
class JsonSuiteTest {

${
        tests.joinToString("\n\n") {
            val theComment = """
        |    /**
        |     * Test generated by [$generatorClassName] based on ${it.rawTestName} in JSONTestSuite (see: ${it.filePathFromProjectRoot})
        |""".trimMargin() +
                    if (it.isSkipped) {
                        "     *\n" +
                                "     * To uncomment and include this test in the running suite, remove it from\n" +
                                "     * [${JsonTestSuiteEditList::class.qualifiedName}] and regenerate this file\n"
                    } else {
                        ""
                    } +
                    """
        |     */
        |""".trimMargin()

            val theTest = """
        |    @Test
        |""".trimMargin() +
                    "    fun ${it.testName}() {\n" +
                    "        assertParseResult(\n" + "            " +
                    "${ResultEnumData.className}.${it.parsingRequirement()},\n" +
                    "            \"\"\"" + it.testSource + "\"\"\"\n" +
                    "        )\n" +
                    "    }"

            theComment + if (it.isSkipped) {
                // comment out our skipped tests
                theTest.split('\n').joinToString("\n//", "//")
            } else {
                theTest
            }
        }
    }
}

private enum class ${ResultEnumData.className} {
    /**
     * Parser must accept the given source as valid JSON
     */
    ${ResultEnumData.acceptEntry},
    
    /**
     * Parser must accept this invalid JSON because it is valid KSON (part of KSON being a superset of JSON)
     */
     ${ResultEnumData.acceptEntryForKson},

    /**
     * Parser must reject the given source as invalid JSON
     */
    ${ResultEnumData.rejectEntry},

    /**
     * The JSON spec does not define a correct response to the given source.
     * i.e. A spec-compliant JSON parser is free accept or reject the given source
     */
    ${ResultEnumData.unspecifiedEntry}
}

private fun assertParseResult(
    expectedParseResult: JsonParseResult,
    source: String
) {
    val parseResult = Kson.parse(source)

    when (expectedParseResult) {
        ${ResultEnumData.className}.${ResultEnumData.acceptEntry}, ${ResultEnumData.className}.${ResultEnumData.acceptEntryForKson} -> assertFalse(
            parseResult.hasErrors(),
            "Should have accepted `" + source + "`, but rejected as invalid.  Errors produced:\n\n" + LoggedMessage.print(parseResult.messages)
        )
        ${ResultEnumData.className}.${ResultEnumData.rejectEntry} -> assertTrue(
            parseResult.hasErrors(),
            "Should have rejected `" + source + "`, but accepted as valid Kson.  Do we a new entry in ${JsonTestSuiteEditList::class.simpleName}?"
        )
        ${ResultEnumData.className}.${ResultEnumData.unspecifiedEntry} -> {
            // no-op: doesn't matter if we accept or reject as long as we didn't blow up
        }
    }
}

"""
}

/**
 * This class manages loading and transforming the [JSONTestSuite](https://github.com/nst/JSONTestSuite)
 * tests to facilitate writing them as native, platform-independent, Kotlin tests in [JsonTestSuiteGenerator]
 *
 * Property [jsonTestSuiteEditList] contains the list of tests we currently skip
 *
 * @param testDefinitionFilesDir the [Path] on disk to the [JSONTestSuite](https://github.com/nst/JSONTestSuite) test files
 * @param projectRoot the [Path] on disk of the project containing [testDefinitionFilesDir] - used to write out
 *                      machine-independent file paths relative to the project root
 */
private class JsonTestDataLoader(private val testDefinitionFilesDir: Path, private val projectRoot: Path) {
    private val testFiles = (testDefinitionFilesDir.toFile().listFiles()
        ?: throw RuntimeException("Should be able to list the files since runCommandLineSetup succeeded"))

    init {
        val testDefinitionFileNames = testFiles.map { it.name }.toSet()

        // ensure all the test names in jsonTestSuiteSkipList are valid
        for (testFileName in JsonTestSuiteEditList.all()) {
            if (!testDefinitionFileNames.contains(testFileName)) {
                throw RuntimeException("Invalid JSONTestSuite test file name \"$testFileName\".\n" +
                        "File not found amongst test files in ${testFiles.first().parentFile}:\n" +
                        testFiles.joinToString(",\n") { it.name })
            }
        }
    }

    fun loadTestData(): List<JsonTestData> {
        return testFiles.map {
            JsonTestData(
                it.nameWithoutExtension,
                // explicitly note UTF-8 here since the JSON spec specifies that as the proper json encoding
                it.readText(Charsets.UTF_8),
                it.absolutePath.replace("$projectRoot/", ""),
                JsonTestSuiteEditList.get(it.name)
            )
        }.sortedBy { it.rawTestName }
    }
}