package org.kson

import org.kson.ast.AstNode
import org.kson.ast.CompileTarget
import org.kson.ast.KsonRoot
import org.kson.collections.ImmutableList
import org.kson.parser.*
import org.kson.parser.messages.MessageType

/**
 * A Json document specifying just `true` is the "trivial" schema that matches everything,
 * and so is equivalent to not having a schema.  See https://json-schema.org/draft/2020-12/json-schema-core#section-4.3.2
 * for more detail
 */
private const val NO_SCHEMA = "true"

class Kson {
    companion object {
        fun parse(source: String, maxNestingLevel: Int = DEFAULT_MAX_NESTING_LEVEL): ParseResult {
            return parse(source, NO_SCHEMA, maxNestingLevel)
        }

        fun parse(source: String, schemaJson: String = NO_SCHEMA, maxNestingLevel: Int = DEFAULT_MAX_NESTING_LEVEL): ParseResult {
            val messageSink = MessageSink()
            val tokens = Lexer(source).tokenize()
            if (tokens[0].tokenType == TokenType.EOF) {
                messageSink.error(tokens[0].lexeme.location, MessageType.BLANK_SOURCE.create())
                return AstParseResult(null, tokens, messageSink)
            }

            val builder = KsonBuilder(tokens)
            Parser(builder, maxNestingLevel).parse()
            val ast = builder.buildTree(messageSink)

            if (schemaJson == NO_SCHEMA) {
                return AstParseResult(ast, tokens, messageSink)
            } else {
                TODO("Json Schema support for Kson not yet implemented")
            }
        }

        /**
         * Parse the given Kson [source] and compile it to Yaml
         *
         * @param source The Kson source to parse
         * @param retainEmbedTags If true, embed blocks will be compiled to objects containing both tag and content.
         *                          Default: false, which means embed blocks are compiled to multi-line strings of the
         *                          block's content
         * @param maxNestingLevel Maximum object/list nesting parser must support in the given Kson
         * @return A [YamlParseResult]
         */
        fun parseToYaml(source: String,
            retainEmbedTags: Boolean = false,
            maxNestingLevel: Int = DEFAULT_MAX_NESTING_LEVEL
        ): YamlParseResult {
            return YamlParseResult(parse(source, maxNestingLevel), retainEmbedTags)
        }
    }
}

/**
 * The type generated by our [Kson] parser
 */
interface ParseResult {
    /**
     * The parsed AST, or null if the source was invalid kson (in which cases [hasErrors] will be true)
     */
    val ast: KsonRoot?

    /**
     * The tokens lexed from the input source, provided for debug purposes
     */
    val lexedTokens: List<Token>

    /**
     * The user-facing messages logged during this parse
     */
    val messages: ImmutableList<LoggedMessage>

    /**
     * True if the input source could not be parsed. [messages] will contain errors in this case.
     */
    fun hasErrors(): Boolean
}

/**
 * Core [ParseResult] produced by the [Kson] parser attempting to create a Kson abstract syntax tree ([ast])
 * from some Kson source
 */
data class AstParseResult(
    override val ast: KsonRoot?,
    override val lexedTokens: List<Token>,
    private val messageSink: MessageSink
) : ParseResult {
    override val messages = messageSink.loggedMessages()

    override fun hasErrors(): Boolean {
        return messageSink.hasErrors()
    }
}

class YamlParseResult(
    val parseResult: ParseResult,
    retainEmbedTags: Boolean = false
) : ParseResult by parseResult {
    /**
     * The Yaml compiled from some Kson source, or null if there were errors trying to parse
     * (consult [parseResult] for information on any errors)
     */
    val yaml: String? = parseResult.ast?.toCommentedSource(AstNode.Indent(), CompileTarget.Yaml(retainEmbedTags))
}